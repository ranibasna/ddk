% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add_knots_validation.R
\name{add_knots_validation}
\alias{add_knots_validation}
\title{Add Quasi-optimal Knots for the Piecewise Constant Basis}
\usage{
add_knots_validation(f, f_v = NULL, knots, L, M = 5)
}
\arguments{
\item{f}{functional data, i.e. matrix of the values row-wise evaluated over equidistant arguments (not given)}

\item{f_v}{functional data i.e. matrix of the values row-wise evaluated over equidistant arguments as the validation data for which the validate the
decreas in the amse over the selected knots outputed from the functional data \code{f}}

\item{knots}{input knots, a sequence of ordered K integers in the range 0:nx, where nx=dim(f)[2]
in between knots intervals are defined open ended on the left hand side (knots[i]) and closed
on the right hand side (knots[i+1]): knots[i]+1,...,knots[i+1]}

\item{L}{number of additional knots}

\item{M}{the minimal number of points per intervals between knots for further split of the optimization to be performed.
The default is 5. It means that if there is less than M points per interval the further split of the interval
marked by knots is not performed. The program will stop if there is too few points to find the requested number
of knots with the given restriction for M.}
}
\value{
A list of the following values
 \item{nknots}{sequence of K+L (old and new) knots}
 \item{NAMSE}{the corresponding sequence of K+L-1 of the within knots
                 average mean square errors}
 \item{APPRERR}{the decreasing sequence of the averaged squared L2 norms:
                ||f1 - hat f1l||_2^2+...+||fn - hat fnl||_2^2, l=0,...,L, where hat f_il are piecewise constant
                approximation of fi's with l knots added to the input knots.  }
}
\description{
Given discretized functional data \code{f} defined over a grid, find the knots that are quasi-optimal for
the piecewise constant basis. It is 'quasi-optimal' since the optimality is locally verified at each
step when a knot is added to already existing ones. There is no guarantee that the final set of knots
is optimal globally over all possible knots of this size.


Utilizing 'add_split' function for evaluation of L new knots only in the intervals that contain
more than the specified (by \code{M}) number of knots. If it is not possible for the function to return the specified by L
number of additional knots a warning message is reported informing what is the maximal number of new knots
that can be added. The knots are added in such a way that it achieves the largest drop in the AMSE (which the sum
of mean squared errors accross all functional data.)
}
\section{References}{
 Nassar, H., Podg√≥rski, K. (2019) Empirically driven
  orthonormal bases for functional data analysis. \emph{Preprint}. Department
  of Statistics, Lund University.
}

\examples{
n=10 #number of samples
#f=rbetafda(n) #generating data
#f=rbetafda(n,ta=3,tb=3) #generating data
nx=1000
f=rbetafda(n,nx,ta=3,tb=3) #generating data

nx=dim(f)[2] #size of the equidistant one dimensional grid
hf=1/(nx+1)  #increment s i z e
grid=matrix( seq (hf , 1-hf , by=hf) , nrow=1) #grid
xx=vector()
for( i in 1:(nx-1)){
  Q=split(f,i)
  xx[i]=Q[1]*i/nx+Q[2]*(nx-i)/nx
}
plot(xx)

AMSE=c(mean((nx-1)/nx*apply(f,1,var)))
knots=c(0,nx) #We take zero as the location of the first knot since, we want intervals pointed
# by 'knots' to be open-close, i.e. the k-th interval is 'knots[k]+1, knots[k+1]'
K=length(knots)
L=30
M=5

KS=add_knots_validation(f,knots=knots,L=10, M = 5)
KS

plot(log(KS$APPRERR))
}
\seealso{
\code{split}  for constructing split at a given knot; \code{opt_split}
for finding the optimal split within one interval; \code{add_splitw}
for selecting  the optimal split from a set of potential splits.

##
# Requires 'rbetafda' function.
}
